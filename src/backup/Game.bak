import {Controller} from '../lib/Controller';
import {GL} from '../lib/GL';
import {InputSystem} from '../lib/InputSystem';
import {PlayerController} from '../lib/PlayerController';
import {Scene} from '../lib/Scene';
import ttt from '../lib/ttt';
import {WebGLRenderer} from '../lib/WebGLRenderer';

new EventSource('/esbuild').addEventListener('change', () => location.reload());

export class Game {
    renderer: WebGLRenderer;
    scene: Scene;
    inputSystem: InputSystem;
    player: PlayerController;
    webglCanvas: HTMLCanvasElement;
    gl: WebGL2RenderingContext;
    xrButton: HTMLButtonElement | undefined;
    xrSession: XRSession | undefined;
    xrRefSpace!: XRReferenceSpace | XRBoundedReferenceSpace;
    //model: {position: any; color: any; indices: any};
    constructor() {
        // Main game setup

        this.inputSystem = new InputSystem();
        this.player = new PlayerController();

        console.log('Game started');

        this.webglCanvas = document.createElement('canvas');
        // Create a WebGL context to render with, initialized to be compatible
        // with the XRDisplay we're presenting to.
        this.gl = this.webglCanvas.getContext('webgl2', {
            xrCompatible: true,
            alpha: false,
        })!;

        this.renderer = new WebGLRenderer(this.gl);
        this.scene = new Scene(this.renderer);
        this.scene.addNode(this.player);

        this.scene.leftHand = new Controller('left');
        this.scene.leftHand.setRenderer(this.renderer);
        this.scene.rightHand = new Controller('right');
        this.scene.rightHand.setRenderer(this.renderer);

        ttt([[32, 32, 13119, 1, 0, 0, 4, 32, 6, 32, 41784, 24856, 33327, 2, 24852, 3, 2, 4100, 1]]).map((x) =>
            document.body.appendChild(x)
        );
        // this.model = initBuffers(this.gl);
        // this.scene.addNode(this.model);
        this.initXR();
    }

    /**
     * Checks to see if WebXR is available and, if so, queries a list of
     * XRDevices that are connected to the system.
     */
    initXR() {
        // Adds a helper button to the page that indicates if any XRDevices are
        // available and let's the user pick between them if there's multiple.
        this.xrButton = document.getElementById('xr-button') as HTMLButtonElement;

        // Is WebXR available on this UA?
        if (navigator.xr) {
            // If the device allows creation of exclusive sessions set it as the
            // target of the 'Enter XR' button.
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                this.xrButton!.innerText = supported ? 'Enter VR' : 'VR not available';
                if (supported) {
                    this.xrButton!.addEventListener('click', this.onRequestSession.bind(this));
                }
            });
        }
    }
    /**
     *  Called when the user selects a device to present to. In response we
     * will request an exclusive session from that device.
     */
    onRequestSession() {
        return navigator.xr!.requestSession('immersive-vr').then(this.onSessionStarted.bind(this));
    }

    /**
     * Called when we've successfully acquired a XRSession. In response we
     * will set up the necessary session state and kick off the frame loop.
     */
    onSessionStarted(session: XRSession) {
        // Listen for the sessions 'end' event so we can respond if the user
        // or UA ends the session for any reason.
        session.addEventListener('end', this.onSessionEnded.bind(this));

        this.xrSession = session; // we set our session to be the session our request created
        this.xrSession.addEventListener('end', this.onSessionEnded.bind(this)); // we set what happenes when our session is ended

        this.xrSession.updateRenderState({
            baseLayer: new XRWebGLLayer(this.xrSession, this.gl),
        }); // this line simply sets our session's WebGL context to our WebGL2 context

        session.updateRenderState({baseLayer: new XRWebGLLayer(session, this.gl)});

        session.requestReferenceSpace('local').then((refSpace) => {
            // make sure the camera starts 1.6m below the floor level
            const xform = new XRRigidTransform({y: -1.6});
            this.xrRefSpace = refSpace.getOffsetReferenceSpace(xform);

            session.requestAnimationFrame(this.onXRFrame.bind(this));
        });
    }

    /**
     * Called either when the user has explicitly ended the session (like in
     * onEndSession()) or when the UA has ended the session for any reason.
     * At this point the session object is no longer usable and should be
     * discarded.
     * @param event The event that caused the session to end.
     */
    onSessionEnded(event) {
        this.xrSession = undefined;
    }

    /** Used for calculating Delta Time */
    prevTime: number | null = null;

    onXRFrame(t: DOMHighResTimeStamp, frame: XRFrame) {
        const session = frame.session;
        let viewerPose;

        // Schedule the next frame to be painted when the time comes.

        session.requestAnimationFrame(this.onXRFrame.bind(this));

        // Get an XRViewerPose representing the position and
        // orientation of the viewer. If successful, render the
        // frame.

        viewerPose = frame.getViewerPose(this.xrRefSpace);
        if (viewerPose) {
            const glLayer = session.renderState.baseLayer!;
            this.gl.bindFramebuffer(GL.FRAMEBUFFER, glLayer.framebuffer);

            // Start by erasing the color and depth framebuffers.

            this.gl.clearColor(0, 0, 0, 1.0);
            this.gl.clearDepth(1.0);
            this.gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

            // Compute the time elapsed since the last frame was rendered.
            // Use this value to ensure your animation runs at the exact
            // rate you intend.
            let deltaTime = 0;
            if (this.prevTime === null) {
                this.prevTime = t;
            } else {
                deltaTime = t - this.prevTime;
                this.prevTime = t;
            }

            // Now call the scene rendering code once for each of
            // the session's views.

            for (const view of viewerPose.views) {
                const viewport = glLayer.getViewport(view)!;
                this.gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                this.myDrawSceneIntoView(view, deltaTime);
            }
        }
    }

    initBuffers() {
        const positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(GL.ARRAY_BUFFER, positionBuffer);

        // Positions for a full-screen quad
        const positions = [60.0, -1, 60.0, -60, -1.0, 60.0, 60, -1.0, -60.0, -60.0, -1.0, -60.0];

        this.gl.bufferData(GL.ARRAY_BUFFER, new Float32Array(positions), GL.STATIC_DRAW);

        return positionBuffer;
    }

    myDrawSceneIntoView(view, deltaTime) {
        // draw a few points
        this.gl.clearColor(0.1, 0.0, 0.0, 1.0); // Clear to black, fully opaque
        this.gl.clearDepth(1.0); // Clear everything
        this.gl.enable(GL.DEPTH_TEST); // Enable depth testing
        this.gl.depthFunc(GL.LEQUAL); // Near things obscure far things
        this.gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        this.gl.useProgram(this.renderer.program);
        let b = this.initBuffers();

        this.gl.enableVertexAttribArray(this.renderer.programInfo?.attribLocations.vertexPosition!);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, b);
        this.gl.vertexAttribPointer(
            this.renderer.programInfo?.attribLocations.vertexPosition!,
            3,
            this.gl.FLOAT,
            false,
            0,
            0
        );
        // this.gl.enableVertexAttribArray(this.renderer.colorAttributeLocation);
        // // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.renderer.colorBuffer);
        // // this.gl.vertexAttribPointer(this.renderer.colorAttributeLocation, 4, this.gl.FLOAT, false, 0, 0);

        this.gl.uniformMatrix4fv(
            this.renderer.programInfo?.uniformLocations.projectionMatrix!,
            false,
            view.projectionMatrix
        );
        this.gl.uniformMatrix4fv(this.renderer.programInfo?.uniformLocations.viewMatrix!, false, view.transform.matrix);

        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * Called every time the XRSession requests that a new frame be drawn.
     */
    onXRFrameOld(t: DOMHighResTimeStamp, frame: XRFrame) {
        let session = frame.session;
        // initialize prevTime on the first run
        // if (this.prevTime === null) {
        //     this.prevTime = t;
        //     session.requestAnimationFrame(this.onXRFrame.bind(this));
        //     return; // skip further execution for this frame
        // }

        // const deltaTime = (t - this.prevTime) / 1000;
        // this.prevTime = t;
        // Per-frame scene setup. Nothing WebXR specific here.
        //scene.startFrame();
        // Inform the session that we're ready for the next frame.
        session.requestAnimationFrame(this.onXRFrame.bind(this));

        // Get the XRDevice pose relative to the Frame of Reference we created
        // earlier.
        let pose = frame.getViewerPose(this.xrRefSpace);

        // this.inputSystem.poll();
        // this.player.update(); //this.inputSystem;
        // this.scene.update(deltaTime);
        // this.scene.render(this.renderer);

        // Getting the pose may fail if, for example, tracking is lost. So we
        // have to check to make sure that we got a valid pose before attempting
        // to render with it. If not in this case we'll just leave the
        // framebuffer cleared, so tracking loss means the scene will simply
        // disappear.
        if (pose) {
            let glLayer = session.renderState.baseLayer!;

            // If we do have a valid pose, bind the WebGL layer's framebuffer,
            // which is where any content to be displayed on the XRDevice must be
            // rendered.
            this.gl.bindFramebuffer(GL.FRAMEBUFFER, glLayer.framebuffer);

            // Clear the framebuffer
            this.gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

            //this.renderer.clear([0.1, 0.1, 0.1, 1]);

            // this.scene.updateInputSources(frame, this.xrRefSpace!);
            // this.scene.updateMatrix();

            // Loop through each of the views reported by the frame and draw them
            // into the corresponding viewport.
            console.log(pose);
            for (let view of pose.views) {
                let viewport = glLayer.getViewport(view)!;

                this.gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                //this.scene.render(view.projectionMatrix, view.transform);
                this.renderer!.draw([], Float32Array.from([]), 0, view.projectionMatrix, view.transform);
            }
        }
    }
}
